(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{187:function(t,s,e){"use strict";e.r(s);var a=e(0),n=Object(a.a)({},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),e("p",[t._v("会根据小数位实现插值算法实现绘制图像的反锯齿效果，如果没有必要请不要选择浮点数值。")]),t._v(" "),t._m(2),t._v(" "),e("p",[t._v("一般在游戏中这个优化方式会经常使用，但是在我们的背景特效中不经常使用，这个优化方式是将经常移动的元素和不经常移动的元素分层，避免不必要的重绘。")]),t._v(" "),e("p",[t._v("比如在游戏中，背景不经常变换和人物这些经常变换的元素分成不同的层，这样需要重绘的资源就会少很多。")]),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),e("p",[t._v("名字听起来很复杂，什么离屏渲染，其实就是设置缓存，绘制图像的时候在屏幕之外的地方绘制好，然后再直接拿过来用，这不就是缓存的概念吗?")]),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),t._m(21),t._v(" "),t._m(22),t._m(23),t._v(" "),t._m(24),t._v(" "),t._m(25),t._v(" "),t._m(26),e("p",[t._v("这里也是要判断下，如果没有使用缓存的话，还是使用最原始的创建圆的方式。")]),t._v(" "),t._m(27),t._v(" "),e("p",[e("a",{attrs:{href:"https://codepen.io/fishcyz/full/RvYZVY",target:"_blank",rel:"noopener noreferrer"}},[t._v("优化效果"),e("OutboundLink")],1)])])},[function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"避免浮点数的坐标点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#避免浮点数的坐标点","aria-hidden":"true"}},[this._v("#")]),this._v(" 避免浮点数的坐标点")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[this._v("绘制图形时，长度与坐标应选取整数而不是浮点数，原因在于 "),s("code",[this._v("Canvas")]),this._v(" 支持半个像素绘制。")])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"使用多层画布去画一个复杂的场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用多层画布去画一个复杂的场景","aria-hidden":"true"}},[this._v("#")]),this._v(" 使用多层画布去画一个复杂的场景")])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"用-css-transforms-特性缩放画布"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#用-css-transforms-特性缩放画布","aria-hidden":"true"}},[this._v("#")]),this._v(" 用 CSS transforms 特性缩放画布")])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("p",[t._v("如果你使用 "),e("code",[t._v("left")]),t._v("、"),e("code",[t._v("top")]),t._v(" 这些 css 属性来写动画的话，那么会触发整个像素渲染流程 "),e("code",[t._v("paint")]),t._v(", "),e("code",[t._v("layout")]),t._v(" 和 "),e("code",[t._v("composition")]),t._v("。")])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("p",[t._v("但是使用 "),e("code",[t._v("transforms")]),t._v(" 中的 "),e("code",[t._v("translateX/Y")]),t._v(" 来切换动画，你将会发现，这并不会触发 "),e("code",[t._v("paint")]),t._v(", "),e("code",[t._v("layout")]),t._v("，仅仅会触发 "),e("code",[t._v("composition")]),t._v(" 的阶段。")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[this._v("这是因为 "),s("code",[this._v("transforms")]),this._v(" 调用的是 GPU 而不是 CPU。")])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"离屏渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#离屏渲染","aria-hidden":"true"}},[this._v("#")]),this._v(" 离屏渲染")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[this._v("建立两个 "),s("code",[this._v("canvas")]),this._v(" 标签，大小一致，一个正常显示，一个隐藏（缓存用的，不插入 dom 中），先将结果 draw 缓存用的 canvas 上下文中，因为游离 canvas 不会造成ui的渲染，所以它不会展现出来，再把缓存的内容整个裁剪再 draw 到正常显示用的 canvas 上，这样能优化不少。")])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"离屏渲染-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#离屏渲染-2","aria-hidden":"true"}},[this._v("#")]),this._v(" 离屏渲染")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[this._v("我们离屏渲染的主要过程就是将一个一个的粒子先在屏幕之外创建出来，然后再使用 "),s("code",[this._v("drawImage()")]),this._v(" 方法将其“放入”到我们的主屏幕中。")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[this._v("首先要在全局设置一个变量 "),s("code",[this._v("useCache")]),this._v(" 来存放我们是否使用离屏渲染这种优化方式。")])},function(){var t=this.$createElement,s=this._self._c||t;return s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[this._v("var useCache = true;\n")])]),this._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[this._v("1")]),s("br")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"round-item-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#round-item-方法","aria-hidden":"true"}},[this._v("#")]),this._v(" Round_item 方法")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[this._v("在 Round_item 原型的 "),s("code",[this._v("draw()")]),this._v(" 方法中来创建每一个离屏的小的 canvas。")])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('function Round_item(index, x, y) { \n    this.index = index; \n    this.x = x; \n    this.y = y; \n    this.useCache = useChache; \n    this.cacheCanvas = document.createElement("canvas"); \n    this.cacheCtx = this.cacheCanvas.getContext("2d"); \n    this.r = Math.random() * 2 + 1; \n    this.cacheCtx.width = 6 * this.r; \n    this.cacheCtx.height = 6 * this.r; \n    var alpha = (Math.floor(Math.random() * 10) + 1) / 10 / 2; \n    this.color = "rgba(255,255,255," + alpha + ")"; \n    if(useChache){ \n        this.cache(); \n    } \n}\n')])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br"),e("span",{staticClass:"line-number"},[t._v("16")]),e("br")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h4",{attrs:{id:"为什么我们这里的-cachecanvas-画布的宽度要设置为-6-倍的半径？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么我们这里的-cachecanvas-画布的宽度要设置为-6-倍的半径？","aria-hidden":"true"}},[this._v("#")]),this._v(" 为什么我们这里的 "),s("code",[this._v("cacheCanvas")]),this._v(" 画布的宽度要设置为 6 倍的半径？")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[this._v("那是因为，我们创建的 "),s("code",[this._v("cacheCanvas")]),this._v(" 不仅仅是有圆，还包括圆的阴影，所以我们要将 "),s("code",[this._v("cacheCanvas")]),this._v(" 的面积设置的稍微大一些，这样才能将圆带阴影一起剪切到我们的主 Canvas 中。")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[this._v("在 "),s("code",[this._v("draw()")]),this._v(" 方法中，我们新创建了 "),s("code",[this._v("cacheCanvas")]),this._v("，并获取到了 "),s("code",[this._v("cacheCanvas")]),this._v(" 的上下文环境，然后设置其宽高。")])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("p",[t._v("然后我们判断了 "),e("code",[t._v("useChache")]),t._v(" 变量的值，也就是说，如果我们将 "),e("code",[t._v("useChache")]),t._v(" 设置为 "),e("code",[t._v("true")]),t._v("，也就是使用缓存，我们就调用 "),e("code",[t._v("this.cache()")]),t._v(" 方法。")])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"this-cache-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this-cache-方法","aria-hidden":"true"}},[this._v("#")]),this._v(" this.cache() 方法")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[this._v("在 "),s("code",[this._v("this.cache()")]),this._v(" 方法中，我们的主要任务是在每一个 "),s("code",[this._v("cacheCanvas")]),this._v(" 中都绘制一个圆。")])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('Round_item.prototype.cache = function () { \n    this.cacheCtx.save(); \n    this.cacheCtx.fillStyle = this.color; \n    this.cacheCtx.shadowColor = "white"; \n    this.cacheCtx.shadowBlur = this.r * 2; \n    this.cacheCtx.beginPath(); \n    this.cacheCtx.arc(this.r * 3, this.r * 3, this.r, 0, 2 * Math.PI); \n    this.cacheCtx.closePath(); \n    this.cacheCtx.fill(); \n    this.cacheCtx.restore(); \n}\n')])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br")])])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("p",[t._v("和在 "),e("code",[t._v("draw()")]),t._v(" 方法中画的圆不同之处是，要注意这里设置的圆心坐标，是 "),e("code",[t._v("this.r * 3")]),t._v("，因为我们创建的 "),e("code",[t._v("cacheCanvas")]),t._v(" 的宽度和高度都是 "),e("code",[t._v("6 * this.r")]),t._v("，我们的圆是要显示在 "),e("code",[t._v("cacheCanvas")]),t._v(" 的正中心，所以设置圆心的坐标应该是 "),e("code",[t._v("this.r * 3,this.r * 3")]),t._v("。")])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"draw-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#draw-方法","aria-hidden":"true"}},[this._v("#")]),this._v(" draw() 方法")])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("p",[t._v("既然设置了 "),e("code",[t._v("cacheCanvas")]),t._v("，那么我们在 "),e("code",[t._v("draw()")]),t._v(" 中，就需要使用 "),e("code",[t._v("Canvas")]),t._v(" 的 "),e("code",[t._v("drawImage")]),t._v(" 方法将 "),e("code",[t._v("cacheCanvas")]),t._v(" 中的你内容显示在屏幕上。")])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Round_item.prototype.draw = function () { \n    if( !useChache){ \n        content.fillStyle = this.color; \n        content.shadowBlur = this.r * 2; \n        content.beginPath(); \n        content.arc(this.x, this.y, this.r, 0, 2 * Math.PI, false); \n        content.closePath(); \n        content.fill(); \n    }else{ \n        content.drawImage(this.cacheCanvas, this.x - this.r, this.y - this.r); \n    } \n};\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"效果"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#效果","aria-hidden":"true"}},[this._v("#")]),this._v(" 效果")])}],!1,null,null,null);n.options.__file="Optimize.md";s.default=n.exports}}]);