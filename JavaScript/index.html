<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>原始（Primitive）类型 | C.AI 的小地盘</title>
    <meta name="description" content="前端工程师 C.AI 的小地盘">
    <link rel="icon" href="/cyz.github.io/img/logo.ico">
    
    <link rel="preload" href="/cyz.github.io/assets/css/0.styles.25a0871d.css" as="style"><link rel="preload" href="/cyz.github.io/assets/js/app.b5debbea.js" as="script"><link rel="preload" href="/cyz.github.io/assets/js/2.5ac5b8d9.js" as="script"><link rel="prefetch" href="/cyz.github.io/assets/js/10.e48ae0ba.js"><link rel="prefetch" href="/cyz.github.io/assets/js/11.24b9e3fd.js"><link rel="prefetch" href="/cyz.github.io/assets/js/12.d0c056e4.js"><link rel="prefetch" href="/cyz.github.io/assets/js/13.30c31171.js"><link rel="prefetch" href="/cyz.github.io/assets/js/14.952f4db7.js"><link rel="prefetch" href="/cyz.github.io/assets/js/15.823c4256.js"><link rel="prefetch" href="/cyz.github.io/assets/js/16.ce052476.js"><link rel="prefetch" href="/cyz.github.io/assets/js/17.d5c7421d.js"><link rel="prefetch" href="/cyz.github.io/assets/js/18.204a3880.js"><link rel="prefetch" href="/cyz.github.io/assets/js/19.076caefb.js"><link rel="prefetch" href="/cyz.github.io/assets/js/20.860809f8.js"><link rel="prefetch" href="/cyz.github.io/assets/js/21.4a608104.js"><link rel="prefetch" href="/cyz.github.io/assets/js/22.511429ff.js"><link rel="prefetch" href="/cyz.github.io/assets/js/23.db1480b4.js"><link rel="prefetch" href="/cyz.github.io/assets/js/24.ec879160.js"><link rel="prefetch" href="/cyz.github.io/assets/js/25.95e08250.js"><link rel="prefetch" href="/cyz.github.io/assets/js/26.14b6917e.js"><link rel="prefetch" href="/cyz.github.io/assets/js/27.3401aa7a.js"><link rel="prefetch" href="/cyz.github.io/assets/js/28.87a8b23f.js"><link rel="prefetch" href="/cyz.github.io/assets/js/29.57a4ab59.js"><link rel="prefetch" href="/cyz.github.io/assets/js/3.d6697f1f.js"><link rel="prefetch" href="/cyz.github.io/assets/js/30.aaab3dcf.js"><link rel="prefetch" href="/cyz.github.io/assets/js/31.80584ceb.js"><link rel="prefetch" href="/cyz.github.io/assets/js/32.318da624.js"><link rel="prefetch" href="/cyz.github.io/assets/js/33.43c107e4.js"><link rel="prefetch" href="/cyz.github.io/assets/js/34.73e25521.js"><link rel="prefetch" href="/cyz.github.io/assets/js/35.49e86e62.js"><link rel="prefetch" href="/cyz.github.io/assets/js/36.c2ce26cb.js"><link rel="prefetch" href="/cyz.github.io/assets/js/37.140bdb7e.js"><link rel="prefetch" href="/cyz.github.io/assets/js/38.e0896d64.js"><link rel="prefetch" href="/cyz.github.io/assets/js/39.caed103f.js"><link rel="prefetch" href="/cyz.github.io/assets/js/4.8d2508b2.js"><link rel="prefetch" href="/cyz.github.io/assets/js/40.dd13eaac.js"><link rel="prefetch" href="/cyz.github.io/assets/js/41.4d80ae4e.js"><link rel="prefetch" href="/cyz.github.io/assets/js/42.4d73d64b.js"><link rel="prefetch" href="/cyz.github.io/assets/js/43.d7d33e7c.js"><link rel="prefetch" href="/cyz.github.io/assets/js/44.7d15bc3c.js"><link rel="prefetch" href="/cyz.github.io/assets/js/45.4f2717ae.js"><link rel="prefetch" href="/cyz.github.io/assets/js/46.4e11f209.js"><link rel="prefetch" href="/cyz.github.io/assets/js/5.a0aefa08.js"><link rel="prefetch" href="/cyz.github.io/assets/js/6.81fd9732.js"><link rel="prefetch" href="/cyz.github.io/assets/js/7.5ee1e9ad.js"><link rel="prefetch" href="/cyz.github.io/assets/js/8.a3a5a21e.js"><link rel="prefetch" href="/cyz.github.io/assets/js/9.4d08f134.js">
    <link rel="stylesheet" href="/cyz.github.io/assets/css/0.styles.25a0871d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/cyz.github.io/" class="home-link router-link-active"><!----> <span class="site-name">C.AI 的小地盘</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/cyz.github.io/" class="nav-link">主页</a></div><div class="nav-item"><a href="/cyz.github.io/about/" class="nav-link">关于</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">JS相关</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cyz.github.io/canvas/" class="nav-link">Canvas</a></li><li class="dropdown-item"><!----> <a href="/cyz.github.io/JavaScript/" class="nav-link router-link-exact-active router-link-active">Javascript语法</a></li><li class="dropdown-item"><!----> <a href="/cyz.github.io/Web/" class="nav-link">重学前端</a></li><li class="dropdown-item"><!----> <a href="/cyz.github.io/TypeScript/" class="nav-link">TypeScript语法</a></li><li class="dropdown-item"><!----> <a href="/cyz.github.io/Node/" class="nav-link">Node</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">CSS相关</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cyz.github.io/CSS/" class="nav-link">常用布局</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Vue相关</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cyz.github.io/Vue/" class="nav-link">基础命令</a></li><li class="dropdown-item"><!----> <a href="/cyz.github.io/VueTree/" class="nav-link">技术栈</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">文档</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cyz.github.io/Applet/" class="nav-link">小程序</a></li><li class="dropdown-item"><!----> <a href="/cyz.github.io/other/webUrl.html" class="nav-link">前端常用url</a></li><li class="dropdown-item"><!----> <a href="/cyz.github.io/other/toolList.html" class="nav-link">前端工具类库</a></li><li class="dropdown-item"><!----> <a href="/cyz.github.io/other/" class="nav-link">其他</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/Fishcyz" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/cyz.github.io/" class="nav-link">主页</a></div><div class="nav-item"><a href="/cyz.github.io/about/" class="nav-link">关于</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">JS相关</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cyz.github.io/canvas/" class="nav-link">Canvas</a></li><li class="dropdown-item"><!----> <a href="/cyz.github.io/JavaScript/" class="nav-link router-link-exact-active router-link-active">Javascript语法</a></li><li class="dropdown-item"><!----> <a href="/cyz.github.io/Web/" class="nav-link">重学前端</a></li><li class="dropdown-item"><!----> <a href="/cyz.github.io/TypeScript/" class="nav-link">TypeScript语法</a></li><li class="dropdown-item"><!----> <a href="/cyz.github.io/Node/" class="nav-link">Node</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">CSS相关</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cyz.github.io/CSS/" class="nav-link">常用布局</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Vue相关</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cyz.github.io/Vue/" class="nav-link">基础命令</a></li><li class="dropdown-item"><!----> <a href="/cyz.github.io/VueTree/" class="nav-link">技术栈</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">文档</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cyz.github.io/Applet/" class="nav-link">小程序</a></li><li class="dropdown-item"><!----> <a href="/cyz.github.io/other/webUrl.html" class="nav-link">前端常用url</a></li><li class="dropdown-item"><!----> <a href="/cyz.github.io/other/toolList.html" class="nav-link">前端工具类库</a></li><li class="dropdown-item"><!----> <a href="/cyz.github.io/other/" class="nav-link">其他</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/Fishcyz" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/cyz.github.io/JavaScript/" class="active sidebar-link">Javascript基本语法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cyz.github.io/JavaScript/#原始（primitive）类型" class="sidebar-link">原始（Primitive）类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cyz.github.io/JavaScript/#共六种" class="sidebar-link">共六种</a></li></ul></li><li class="sidebar-sub-header"><a href="/cyz.github.io/JavaScript/#对象（object）类型" class="sidebar-link">对象（Object）类型</a></li><li class="sidebar-sub-header"><a href="/cyz.github.io/JavaScript/#typeof-vs-instanceof" class="sidebar-link">typeof vs instanceof</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cyz.github.io/JavaScript/#instanceof-判断原始类型的" class="sidebar-link">instanceof 判断原始类型的</a></li></ul></li><li class="sidebar-sub-header"><a href="/cyz.github.io/JavaScript/#类型转换" class="sidebar-link">类型转换</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cyz.github.io/JavaScript/#转boolean" class="sidebar-link">转Boolean</a></li><li class="sidebar-sub-header"><a href="/cyz.github.io/JavaScript/#对象转原始类型" class="sidebar-link">对象转原始类型</a></li><li class="sidebar-sub-header"><a href="/cyz.github.io/JavaScript/#四则运算符" class="sidebar-link">四则运算符</a></li><li class="sidebar-sub-header"><a href="/cyz.github.io/JavaScript/#比较运算符" class="sidebar-link">比较运算符</a></li></ul></li><li class="sidebar-sub-header"><a href="/cyz.github.io/JavaScript/#this" class="sidebar-link">this</a></li><li class="sidebar-sub-header"><a href="/cyz.github.io/JavaScript/#vs" class="sidebar-link">== vs ===</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cyz.github.io/JavaScript/#判断流程：" class="sidebar-link">判断流程：</a></li></ul></li><li class="sidebar-sub-header"><a href="/cyz.github.io/JavaScript/#闭包" class="sidebar-link">闭包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cyz.github.io/JavaScript/#循环中使用闭包解决-var-定义函数的问题" class="sidebar-link">循环中使用闭包解决 var 定义函数的问题</a></li></ul></li><li class="sidebar-sub-header"><a href="/cyz.github.io/JavaScript/#深浅拷贝" class="sidebar-link">深浅拷贝</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cyz.github.io/JavaScript/#浅拷贝" class="sidebar-link">浅拷贝</a></li><li class="sidebar-sub-header"><a href="/cyz.github.io/JavaScript/#深拷贝" class="sidebar-link">深拷贝</a></li></ul></li><li class="sidebar-sub-header"><a href="/cyz.github.io/JavaScript/#原型" class="sidebar-link">原型</a></li></ul></li><li><a href="/cyz.github.io/JavaScript/ES6.html" class="sidebar-link">ES6基础</a></li><li><a href="/cyz.github.io/JavaScript/JavascriptObject.html" class="sidebar-link">Javascript对象</a></li></ul> </div> <div class="page"> <div class="content"><h2 id="原始（primitive）类型"><a href="#原始（primitive）类型" aria-hidden="true" class="header-anchor">#</a> 原始（Primitive）类型</h2> <blockquote><p>涉及面试题：原始类型有哪几种？null 是对象嘛？</p></blockquote> <h3 id="共六种"><a href="#共六种" aria-hidden="true" class="header-anchor">#</a> 共六种</h3> <ul><li><code>boolean</code></li> <li><code>null</code></li> <li><code>undefined</code></li> <li><code>number</code></li> <li><code>string</code></li> <li><code>symbol</code></li></ul> <blockquote><p>Tips</p></blockquote> <ol><li>原始类型存储的都是值，是没有函数可以调用的</li> <li>JS 的 number 类型是浮点类型的</li> <li>string 类型是不可变的，无论你在 string 类型上调用何种方法，都不会对值有改变</li> <li>虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug</li></ol> <h2 id="对象（object）类型"><a href="#对象（object）类型" aria-hidden="true" class="header-anchor">#</a> 对象（Object）类型</h2> <blockquote><p>涉及面试题：对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？</p></blockquote> <ul><li>在 JS 中，除了原始类型那么其他的都是对象类型了。</li> <li>对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>function test(person) {
  person.age = 26
  person = {
    name: 'yyy',
    age: 30
  }

  return person
}
const p1 = {
  name: 'yck',
  age: 25
}
const p2 = test(p1)
console.log(p1) // -&gt; age: 26, name: &quot;yck&quot;
console.log(p2) // -&gt; age: 30, name: &quot;yyy&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><ul><li>函数传参是传递对象指针的副本</li></ul> <h2 id="typeof-vs-instanceof"><a href="#typeof-vs-instanceof" aria-hidden="true" class="header-anchor">#</a> typeof vs instanceof</h2> <blockquote><p>涉及面试题：typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？</p></blockquote> <ul><li>typeof 对于原始类型来说，除了 null 都可以显示正确的类型</li> <li>typeof 对于对象来说，除了函数都会显示 object</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>typeof 1 // 'number'
typeof '1' // 'string'
typeof undefined // 'undefined'
typeof true // 'boolean'
typeof Symbol() // 'symbol'
typeof [] // 'object'
typeof {} // 'object'
typeof console.log // 'function'
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>对于原始类型来说，你想直接通过 instanceof 来判断类型是不行的</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>const Person = function() {}
const p1 = new Person()
p1 instanceof Person // true

var str = 'hello world'
str instanceof String // false

var str1 = new String('hello world')
str1 instanceof String // true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="instanceof-判断原始类型的"><a href="#instanceof-判断原始类型的" aria-hidden="true" class="header-anchor">#</a> instanceof 判断原始类型的</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>class PrimitiveString {
  static [Symbol.hasInstance](x) {
    return typeof x === 'string'
  }
}
console.log('hello world' instanceof PrimitiveString) // true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Symbol.hasInstance：自定义 instanceof 行为</p> <h2 id="类型转换"><a href="#类型转换" aria-hidden="true" class="header-anchor">#</a> 类型转换</h2> <p>在 JS 中类型转换只有三种情况，分别是：</p> <ul><li>转换为布尔值</li> <li>转换为数字</li> <li>转换为字符串</li></ul> <table><thead><tr><th style="text-align:center">原始值</th> <th style="text-align:center">转换目标</th> <th>结果</th></tr></thead> <tbody><tr><td style="text-align:center">number</td> <td style="text-align:center">布尔值</td> <td>除了0、-0、NaN都为true</td></tr> <tr><td style="text-align:center">string</td> <td style="text-align:center">布尔值</td> <td>除了空串都为true</td></tr> <tr><td style="text-align:center">underfined、null</td> <td style="text-align:center">布尔值</td> <td>false</td></tr> <tr><td style="text-align:center">引用类型</td> <td style="text-align:center">布尔值</td> <td>true</td></tr> <tr><td style="text-align:center">number</td> <td style="text-align:center">字符串</td> <td>5=&gt;'5'</td></tr> <tr><td style="text-align:center">Boolean、函数、Symbol</td> <td style="text-align:center">字符串</td> <td>‘true’</td></tr> <tr><td style="text-align:center">数组</td> <td style="text-align:center">字符串</td> <td>[1,2]=&gt;'1,2'</td></tr> <tr><td style="text-align:center">对象</td> <td style="text-align:center">字符串</td> <td>'[object Object]'</td></tr> <tr><td style="text-align:center">string</td> <td style="text-align:center">数字</td> <td>'1'=&gt;1,'a'=&gt;NaN</td></tr> <tr><td style="text-align:center">数组</td> <td style="text-align:center">数字</td> <td>空数组为0，存在一个元素且为数字转数字，其他情况为NaN</td></tr> <tr><td style="text-align:center">null</td> <td style="text-align:center">数字</td> <td>0</td></tr> <tr><td style="text-align:center">除了数组的引用类型</td> <td style="text-align:center">数字</td> <td>NaN</td></tr> <tr><td style="text-align:center">Symbol</td> <td style="text-align:center">数字</td> <td>抛错</td></tr></tbody></table> <h3 id="转boolean"><a href="#转boolean" aria-hidden="true" class="header-anchor">#</a> 转Boolean</h3> <p>在条件判断时，除了 undefined， null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象。</p> <h3 id="对象转原始类型"><a href="#对象转原始类型" aria-hidden="true" class="header-anchor">#</a> 对象转原始类型</h3> <p>对象在转换类型的时候，会调用内置的 [[ToPrimitive]] 函数</p> <ul><li>如果已经是原始类型了，那就不需要转换了</li> <li>调用 x.valueOf()，如果转换为基础类型，就返回转换的值</li> <li>调用 x.toString()，如果转换为基础类型，就返回转换的值</li> <li>如果都没有返回原始类型，就会报错</li></ul> <blockquote><p>你也可以重写 Symbol.toPrimitive ，该方法在转原始类型时调用优先级最高</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>let a = {
  valueOf() {
    return 0
  },
  toString() {
    return '1'
  },
  [Symbol.toPrimitive]() {
    return 2
  }
}
1 + a // =&gt; 3
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="四则运算符"><a href="#四则运算符" aria-hidden="true" class="header-anchor">#</a> 四则运算符</h3> <p>加法运算符不同于其他几个运算符，它有以下几个特点：</p> <ul><li>运算中其中一方为字符串，那么就会把另一方也转换为字符串</li> <li>如果一方不是字符串或者数字，那么会将它转换为数字或者字符串</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>1 + '1' // '11'（将数字 1 转换为字符串）
true + true // 2（将 true 转为数字 1）
4 + [1,2,3] // &quot;41,2,3&quot;（将数组通过 toString 转为字符串 1,2,3）
'a' + + 'b' // -&gt; &quot;aNaN&quot;（+ 'b' 等于 NaN，所以结果为 &quot;aNaN&quot;）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>只要其中一方是数字，那么另一方就会被转为数字</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>4 * '3' // 12
4 * [] // 0
4 * [1, 2] // NaN
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="比较运算符"><a href="#比较运算符" aria-hidden="true" class="header-anchor">#</a> 比较运算符</h3> <ul><li>如果是对象，就通过 toPrimitive 转换对象</li> <li>如果是字符串，就通过 unicode 字符索引来比较</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>let a = {
  valueOf() {
    return 0
  },
  toString() {
    return '1'
  }
}
a &gt; -1 // true（因为 a 是对象，所以会通过 valueOf 转换为原始类型再比较值）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="this"><a href="#this" aria-hidden="true" class="header-anchor">#</a> this</h2> <blockquote><p>如何正确判断 this？箭头函数的 this 是什么？</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>function foo() {
  console.log(this.a)
}
var a = 1
foo()
&lt;!-- 对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window --&gt;

const obj = {
  a: 2,
  foo: foo
}
obj.foo()
&lt;!-- 对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象 --&gt;

const c = new foo()
&lt;!-- 对于 new 的方式来说，this 被永远绑定在了 c 上面，不会被任何方式改变 this --&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>箭头函数中的 this：箭头函数其实是没有 this 的，箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this。
对箭头函数使用 bind 这类函数是无效的。</p> <p>bind 这些改变上下文的 API 来说，this 取决于第一个参数，如果第一个参数为空，那么就是 window。</p> <blockquote><p>new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。</p></blockquote> <p><img src="/cyz.github.io/assets/img/this.de3a8b15.png" alt="this" title="this"></p> <h2 id="vs"><a href="#vs" aria-hidden="true" class="header-anchor">#</a> == vs ===</h2> <blockquote><p>== 和 === 有什么区别？
对于 == 来说，如果对比双方的类型不一样的话，就会进行类型转换</p></blockquote> <h3 id="判断流程："><a href="#判断流程：" aria-hidden="true" class="header-anchor">#</a> 判断流程：</h3> <ol><li>首先会判断两者类型是否相同。相同的话就是比大小了</li> <li>类型不相同的话，那么就会进行类型转换</li> <li>会先判断是否在对比 null 和 undefined，是的话就会返回 true</li> <li>判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number</li> <li>判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断</li> <li>判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断
<img src="/cyz.github.io/assets/img/==.6864123f.png" alt="==" title="=="></li></ol> <h2 id="闭包"><a href="#闭包" aria-hidden="true" class="header-anchor">#</a> 闭包</h2> <blockquote><p>什么是闭包？</p></blockquote> <p>闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。</p> <p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。</p> <h3 id="循环中使用闭包解决-var-定义函数的问题"><a href="#循环中使用闭包解决-var-定义函数的问题" aria-hidden="true" class="header-anchor">#</a> 循环中使用闭包解决 <code>var</code> 定义函数的问题</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>for (var i = 1; i &lt;= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="解决办法"><a href="#解决办法" aria-hidden="true" class="header-anchor">#</a> 解决办法</h4> <ol><li>使用闭包的方式<div class="language- line-numbers-mode"><pre class="language-text"><code>for (var i = 1; i &lt;= 5; i++) {
    ;(function(j) {
        setTimeout(function timer() {
        console.log(j)
        }, j * 1000)
    })(i)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div>我们首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的。</li> <li>使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入。<div class="language- line-numbers-mode"><pre class="language-text"><code>for (var i = 1; i &lt;= 5; i++) {
    setTimeout(
        function timer(j) {
            console.log(j)
        },
        i * 1000,
        i
    )
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li> <li>使用 let 定义 i<div class="language- line-numbers-mode"><pre class="language-text"><code>for (let i = 1; i &lt;= 5; i++) {
    setTimeout(function timer() {
        console.log(i)
    }, i * 1000)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ol> <h2 id="深浅拷贝"><a href="#深浅拷贝" aria-hidden="true" class="header-anchor">#</a> 深浅拷贝</h2> <blockquote><p>什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？</p></blockquote> <h3 id="浅拷贝"><a href="#浅拷贝" aria-hidden="true" class="header-anchor">#</a> 浅拷贝</h3> <ol><li><p>通过 Object.assign</p> <p>Object.assign 只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let a = {
    age: 1
}
let b = Object.assign({}, a)
a.age = 2
console.log(b.age) // 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>通过展开运算符 <code>...</code></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let a = {
    age: 1
}
let b = { ...a }
a.age = 2
console.log(b.age) // 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li></ol> <h3 id="深拷贝"><a href="#深拷贝" aria-hidden="true" class="header-anchor">#</a> 深拷贝</h3> <ol><li><p>JSON.parse(JSON.stringify(object))</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let a = {
age: 1,
jobs: {
    first: 'FE'
}
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = 'native'
console.log(b.jobs.first) // FE
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ul><li><strong>局限性</strong> <ul><li>会忽略 undefined</li> <li>会忽略 symbol</li> <li>不能序列化函数</li> <li>不能解决循环引用的对象</li></ul></li></ul></li> <li><p>如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 MessageChannel</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function structuralClone(obj) {
    return new Promise(resolve =&gt; {
        const { port1, port2 } = new MessageChannel()
        port2.onmessage = ev =&gt; resolve(ev.data)
        port1.postMessage(obj)
    })
}

var obj = {
    a: 1,
    b: {
        c: 2
    }
}

obj.b.d = obj.b

// 注意该方法是异步的
// 可以处理 undefined 和循环引用对象
const test = async () =&gt; {
    const clone = await structuralClone(obj)
    console.log(clone)
}
test()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div></li> <li><p>lodash 的深拷贝函数</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function deepClone(obj) {
    function isObject(o) {
        return (typeof o === 'object' || typeof o === 'function') &amp;&amp; o !== null
    }

    if (!isObject(obj)) {
        throw new Error('非对象')
    }

    let isArray = Array.isArray(obj)
    let newObj = isArray ? [...obj] : { ...obj }
    Reflect.ownKeys(newObj).forEach(key =&gt; {
        newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]
    })

    return newObj
}

let obj = {
    a: [1, 2, 3],
    b: {
        c: 2,
        d: 3
    }
}
let newObj = deepClone(obj)
newObj.b.c = 1
console.log(obj.b.c) // 2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div></li></ol> <h2 id="原型"><a href="#原型" aria-hidden="true" class="header-anchor">#</a> 原型</h2> <blockquote><p>如何理解原型？如何理解原型链？</p></blockquote> <p>每个 JS 对象都有 <strong>proto</strong> 属性</p> <p><img src="/cyz.github.io/assets/img/proto.ce4b0fc8.png" alt="proto" title="__proto__"></p> <p><img src="/cyz.github.io/assets/img/proto_1.0eda1a47.png" alt="proto" title="__proto__"></p> <ul><li>Object 是所有对象的爸爸，所有对象都可以通过 <strong>proto</strong> 找到它</li> <li>Function 是所有函数的爸爸，所有函数都可以通过 <strong>proto</strong> 找到它</li> <li>函数的 prototype 是一个对象</li> <li>对象的 <strong>proto</strong> 属性指向原型， <strong>proto</strong> 将对象和原型连接起来组成了原型链</li></ul></div> <div class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">7/12/2019, 9:47:58 AM</span></div></div> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/cyz.github.io/JavaScript/ES6.html">
          ES6基础
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/cyz.github.io/assets/js/app.b5debbea.js" defer></script><script src="/cyz.github.io/assets/js/2.5ac5b8d9.js" defer></script>
  </body>
</html>
